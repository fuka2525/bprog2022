GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/fuka/bprog2022/.ghci
2022-05-19 15:41:29.794328234
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/fuka/bprog2022/.ghci
2022-05-19 15:50:26.598637218
>>> 23+5
28
2022-05-19 15:54:15.002329245
>>> 3+2*5
13
2022-05-19 15:55:23.12443847
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/fuka/bprog2022/.ghci
2022-05-19 15:57:10.683299549
>>> 3+2
5
2022-05-19 15:57:22.495642993
>>> sqrt 2
1.4142135623730951
2022-05-19 15:59:46.298187729
>>> double 3

<interactive>:3:1: error: Variable not in scope: double :: t0 -> t
2022-05-19 16:02:06.835437997
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/fuka/bprog2022/.ghci
2022-05-26 15:02:12.306024901
>>> maxBound :: Int
9223372036854775807
2022-05-26 15:04:20.815154646
>>> 2 ^ 63 - 1
9223372036854775807
2022-05-26 15:05:09.056916058
>>> minBound :: Int
-9223372036854775808
2022-05-26 15:05:46.508294638
>>> :e src/First.hs
   1  module First where
   2  
   3      double :: Int  -> Int
   4      double x = x + X
Ok, no modules loaded.
:l src/First.hs
2022-05-26 15:49:11.824917889
>>> [1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:4:20: error: Data constructor not in scope: X :: Int
  |
4 |     double x = x + X
  |                    ^
Failed, no modules loaded.
2022-05-26 15:49:11.880334446
>>> 
2022-05-26 15:52:17.167797848
>>> :e src/First.hs
   1  module First where
   2  
   3      double :: Int  -> Int
   4      double x = x + x
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-05-26 15:53:22.341955844
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-05-26 15:53:22.442734664
>>> double 3
6
2022-05-26 15:56:21.018215653
>>> double 123
246
2022-05-26 15:56:33.407004673
>>> double (1+2）

<interactive>:11:12: error: lexical error at end of input
2022-05-26 15:57:19.481112831
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/fuka/bprog2022/.ghci
2022-06-09 14:55:18.116972839
>>> 2 + 3 * 4
14
2022-06-09 14:58:39.563664047
>>> （2 + 3 ）* 4

<interactive>:2:1: error: lexical error at character '2'
2022-06-09 15:00:59.159788372
>>> (2 + 3 ) * 4
20
2022-06-09 15:02:17.905279989
>>> sqrt (3 ^ 2 + 4 ^ 2 )
5.0
2022-06-09 15:05:15.749043235
>>> sqrt ( 25 :: Int)

<interactive>:5:1: error:
    • No instance for (Floating Int) arising from a use of ‘sqrt’
    • In the expression: sqrt (25 :: Int)
      In an equation for ‘it’: it = sqrt (25 :: Int)
2022-06-09 15:08:42.284208793
>>> sqrt ( 25 :: Double)
5.0
2022-06-09 15:09:55.566709654
>>> sqre 25

<interactive>:7:1: error:
    • Variable not in scope: sqre :: t0 -> t
    • Perhaps you meant ‘sqrt’ (imported from Prelude)
2022-06-09 15:10:05.225723066
>>> sqrt 25
5.0
2022-06-09 15:10:19.165331278
>>> hoge 25 :: Int

<interactive>:9:1: error: Variable not in scope: hoge :: t0 -> Int
2022-06-09 15:13:31.902058631
>>> head [1, 2, 3]
1
2022-06-09 15:46:21.55869119
>>> head [3, 1, 4, 1, 5]
3
2022-06-09 15:46:47.964706729
>>> head [ ]
*** Exception: Prelude.head: empty list
2022-06-09 15:48:36.677995328
>>> hoge = [ 3, 1, 4, 1, 5,] :: [Int]

<interactive>:13:24: error: parse error on input ‘]’
2022-06-09 15:50:47.948920578
>>> hoge

<interactive>:14:1: error: Variable not in scope: hoge
2022-06-09 15:51:16.463476283
>>> head hoge

<interactive>:15:6: error: Variable not in scope: hoge :: [a]
2022-06-09 15:51:29.962659763
>>> hoge = [3, 1, 4, 1, 5] :: [Int]
2022-06-09 15:52:12.167000572
>>> hoge
[3,1,4,1,5]
2022-06-09 15:52:21.51532834
>>> head hoge
3
2022-06-09 15:52:38.565359477
>>> tail hoge
[1,4,1,5]
2022-06-09 15:52:51.69496303
>>> tail []
*** Exception: Prelude.tail: empty list
2022-06-09 15:53:02.019793247
>>> hoge !! 0
3
2022-06-09 15:55:10.371792839
>>> hoge !! 2
4
2022-06-09 15:56:24.499237349
>>> take 3 hoge
[3,1,4]
2022-06-09 15:56:55.220631833
>>> hoge
[3,1,4,1,5]
2022-06-09 15:57:03.169654901
>>> drop 3 hoge
[1,5]
2022-06-09 15:57:25.492945759
>>> hoge 5 hoge

<interactive>:26:1: error:
    • Couldn't match expected type: t0 -> [Int] -> t
                  with actual type: [Int]
    • The function ‘hoge’ is applied to two value arguments,
        but its type ‘[Int]’ has none
      In the expression: hoge 5 hoge
      In an equation for ‘it’: it = hoge 5 hoge
    • Relevant bindings include it :: t (bound at <interactive>:26:1)
2022-06-09 15:58:23.876911451
>>> hoge !! 5
*** Exception: Prelude.!!: index too large
2022-06-09 15:58:56.762874669
>>> take 10 hoge
[3,1,4,1,5]
2022-06-09 15:59:20.743856589
>>> drop 10 hoge
[]
2022-06-09 15:59:55.039073075
>>> length hoge
5
2022-06-09 16:01:08.010711536
>>> length []
0
2022-06-09 16:01:23.557419788
>>> sum hoge
14
2022-06-09 16:02:03.804182398
>>> product hoge
60
2022-06-09 16:03:04.236329538
>>> hoge ++ hoge
[3,1,4,1,5,3,1,4,1,5]
2022-06-09 16:04:56.112454627
>>> reverse hoge
[5,1,4,1,3]
2022-06-09 16:05:35.34955163
>>> :e src/First.hs
   1  module First where
   2  
   3      double :: Int  -> Int
   4      double x = x + x
Ok, no modules loaded.
2022-06-09 16:07:54.411976089
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:07:54.46951952
>>> double 3 + 3
9
2022-06-09 16:08:49.1002785
>>> double (3 + 3)
12
2022-06-09 16:11:29.600302919
>>> quadruble 2

<interactive>:40:1: error:
    Variable not in scope: quadruble :: t0 -> t
2022-06-09 16:15:16.342336904
>>> :quit
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/fuka/bprog2022/.ghci
2022-06-16 15:02:08.521986944
>>> take 3 [3,1,4,1,5]
[3,1,4]
2022-06-16 15:04:24.706692076
>>> :e src/First.hs
   1  module First where
   2  
   3      double :: Int  -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple X = double  (double x)
Ok, no modules loaded.
2022-06-16 15:11:01.075623601
>>> :l  src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:7:15: error: Not in scope: data constructor ‘X’
  |
7 |     quadruple X = double  (double x)
  |               ^
Failed, no modules loaded.
2022-06-16 15:11:01.148525828
>>> double

<interactive>:4:1: error: Variable not in scope: double
2022-06-16 15:13:01.589273186
>>> take (double 2) [1,2,3,4,5]

<interactive>:5:7: error:
    Variable not in scope: double :: t0 -> Int
2022-06-16 15:15:34.495543062
>>> take (double 2 ) [1,2,3,4,5]

<interactive>:6:7: error:
    Variable not in scope: double :: t0 -> Int
2022-06-16 15:17:03.155380889
>>> [1 .. 10]
[1,2,3,4,5,6,7,8,9,10]
2022-06-16 15:20:43.33784577
>>> :e
   1  module First where
   2  
   3      double :: Int  -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple X = double  (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:7:15: error: Not in scope: data constructor ‘X’
  |
7 |     quadruple X = double  (double x)
  |               ^
Failed, no modules loaded.
2022-06-16 15:21:09.879719046
>>> :e
   1  module First where
   2  
   3      double :: Int  -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double  (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:24:21.376886549
>>> factorial 3
6
2022-06-16 15:24:50.491339803
>>> factorial 4
24
2022-06-16 15:25:03.905866718
>>> :e
   1  module First where
   2  
   3      double :: Int  -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double  (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: Int -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:13:22: error:
    • Couldn't match expected type ‘t0 Int’ with actual type ‘Int’
    • In the first argument of ‘sum’, namely ‘xs’
      In the first argument of ‘div’, namely ‘sum xs’
      In the expression: sum xs `div` length xs
   |
13 |     average xs = sum xs `div` length xs
   |                      ^^

src/First.hs:13:38: error:
    • Couldn't match expected type ‘t1 a0’ with actual type ‘Int’
    • In the first argument of ‘length’, namely ‘xs’
      In the second argument of ‘div’, namely ‘length xs’
      In the expression: sum xs `div` length xs
   |
13 |     average xs = sum xs `div` length xs
   |                                      ^^
Failed, no modules loaded.
2022-06-16 15:38:17.334844544
>>> :e
   1  module First where
   2  
   3      double :: Int  -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double  (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:39:46.607875223
>>> average [1,2,3,4,5]
3
2022-06-16 15:40:30.004073493
>>> :t take 3 [1,2,3,4,5]
take 3 [1,2,3,4,5] :: Num a => [a]
2022-06-16 15:49:55.826076983
>>> init [1 .. 5]
[1,2,3,4]
2022-06-16 16:07:03.703043838
>>> :e
   1  module First where
   2  
   3      double :: Int  -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double  (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
  17  
  18      myinit :: [a] -> [a]
  19      myinit (x:[]) = []
  20      myinit (x:xs) = x : (init xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 16:14:42.020772197
>>> myinit [1 .. 5]
[1,2,3,4]
2022-06-16 16:14:57.489006183
>>> myinit []
*** Exception: src/First.hs:(19,5)-(20,33): Non-exhaustive patterns in function myinit

2022-06-16 16:15:10.697204187
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/fuka/bprog2022/.ghci
2022-06-23 14:55:02.083169202
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-06-23 14:56:36.808710646
>>> >>> 1 == 2

<interactive>:2:1: error: parse error on input ‘>>>’
2022-06-23 15:06:22.885084651
>>> 1 == 2
False
2022-06-23 15:06:28.689555677
>>> 1 < 2
True
2022-06-23 15:06:39.725215208
>>> 1 < 1
False
2022-06-23 15:06:47.181780881
>>> 1 >-2

<interactive>:6:3: error:
    • Variable not in scope: (>-) :: t0 -> t1 -> t
    • Perhaps you meant one of these:
        ‘-’ (imported from Prelude), ‘>=’ (imported from Prelude),
        ‘>>’ (imported from Prelude)
2022-06-23 15:06:56.296804153
>>> 1>= 2
False
2022-06-23 15:07:09.637774864
>>> `a` < `b`

<interactive>:8:1: error: parse error on input ‘`’
2022-06-23 15:11:32.543998904
>>> `` < `a`

<interactive>:9:1: error: parse error on input ‘`’
2022-06-23 15:12:32.508253141
>>> `ab` < `b`

<interactive>:10:1: error: parse error on input ‘`’
2022-06-23 15:13:00.13040737
>>> 1 /= 2
True
2022-06-23 15:16:05.46663799
>>>  :info abs
type Num :: * -> Constraint
class Num a where
  ...
  abs :: a -> a
  ...
  	-- Defined in ‘GHC.Num’
2022-06-23 15:30:23.302159514
>>> abs

<interactive>:13:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-23 15:30:48.777955325
>>> abs (-234)
234
2022-06-23 15:34:47.066735937
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/fuka/bprog2022/.ghci
2022-06-30 14:56:40.412752112
>>> [ x ^ 2 | x <- [1 .. 5] ]
[1,4,9,16,25]
2022-06-30 15:02:11.850443763
>>> map (^2) [1..5]
[1,4,9,16,25]
2022-06-30 15:05:05.014413555
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/fuka/bprog2022/.ghci
2022-06-30 15:12:23.400855247
>>> [ x 'div' 2 | x <- [1 .. 5]]

<interactive>:1:5: error:
    • Syntax error on 'div'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'div'
2022-06-30 15:13:40.610943641
>>> [ x 'divMod' 2 | x <- [1 .. 5]]

<interactive>:2:5: error:
    • Syntax error on 'divMod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'divMod'
2022-06-30 15:15:59.959941237
>>> [ (x, y) | x <- "abc", y <- [4,5] ]
[('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
2022-06-30 15:21:09.574856933
>>> [(x, y) | y <- [4, 5], x <- "abc" ]
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-06-30 15:22:07.079680483
>>> 
2022-06-30 15:26:52.263920732
>>> [1 of 1] Compiling First  (src/First.hs, interpreted)

<interactive>:6:4: error: parse error on input ‘of’
2022-06-30 15:28:15.272596525
>>> [1 of 1] Compiling First 

<interactive>:7:4: error: parse error on input ‘of’
2022-06-30 15:29:02.057768436
>>> :e src/First.hs
   1  module First where
   2  
   3      double :: Int  -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double  (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
  17  
  18      myinit :: [a] -> [a]
  19      myinit (x:[]) = []
  20      myinit (x:xs) = x : (init xs)
  21  
  22      myconcat :: [[a]] -> [a]
  23      myconcat xss = [x | xs <- xss , x <- xs]
Ok, no modules loaded.
2022-06-30 15:29:51.904605365
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:29:52.007775723
>>> [1 of 1] Compiling First

<interactive>:10:4: error: parse error on input ‘of’
2022-06-30 15:30:38.953547123
>>> [1 of 1] Compiling First.hs

<interactive>:11:4: error: parse error on input ‘of’
2022-06-30 15:33:34.587845396
>>> [ 1 | _ <- [1 .. 5] ]
[1,1,1,1,1]
2022-06-30 15:47:32.920670536
>>> [1 of 1] Compiling First

<interactive>:13:4: error: parse error on input ‘of’
2022-06-30 15:50:32.605081453
>>> ['a'

<interactive>:14:5: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-30 15:50:48.684273012
>>> ['a' .. 'z']
"abcdefghijklmnopqrstuvwxyz"
2022-06-30 15:51:07.895764681
>>> ['あ' .. 'ん']
"\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\12366\12367\12368\12369\12370\12371\12372\12373\12374\12375\12376\12377\12378\12379\12380\12381\12382\12383\12384\12385\12386\12387\12388\12389\12390\12391\12392\12393\12394\12395\12396\12397\12398\12399\12400\12401\12402\12403\12404\12405\12406\12407\12408\12409\12410\12411\12412\12413\12414\12415\12416\12417\12418\12419\12420\12421\12422\12423\12424\12425\12426\12427\12428\12429\12430\12431\12432\12433\12434\12435"
2022-06-30 15:52:00.058896523
>>> putStrLn it
あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをん
2022-06-30 15:52:56.411581417
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/fuka/bprog2022/.ghci
2022-07-07 16:05:03.202906659
>>> :e src/Caesar .hs
catn: src/Caesar: openFile: does not exist (No such file or directory)
2022-07-07 16:05:38.140570835
>>> :l src/Caesar .hs

<no location info>: error: can't find file: .hs
Failed, no modules loaded.
2022-07-07 16:05:38.208593008
>>> ord 'A '

<interactive>:3:9: error:
    lexical error in string/character literal at end of input
2022-07-07 16:05:54.67158995
>>> ord 'A'

<interactive>:4:1: error:
    • Variable not in scope: ord :: Char -> t
    • Perhaps you meant one of these:
        ‘or’ (imported from Prelude), ‘odd’ (imported from Prelude)
2022-07-07 16:06:13.595830657
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char

<no location info>: error: can't find file: .hs
Failed, no modules loaded.
2022-07-07 16:07:21.931129188
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:07:22.018350192
>>> :e src/Caesar where
catn: src/Caesar: openFile: does not exist (No such file or directory)
2022-07-07 16:07:56.647356743
>>> :l src/Caesar where
target ‘where’ is not a module name or a source file
2022-07-07 16:07:56.744385463
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
Ok, one module loaded.
2022-07-07 16:09:42.045185043
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:09:42.141835095
>>> import Data.Char
2022-07-07 16:10:09.916987566
>>> ord 'a'
97
2022-07-07 16:10:43.822388716
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/fuka/bprog2022/.ghci
2022-07-14 15:11:27.561707755
>>> :e src/Caesar .hs
catn: src/Caesar: openFile: does not exist (No such file or directory)
2022-07-14 15:12:29.709812482
>>> :l src/Caesar .hs

<no location info>: error: can't find file: .hs
Failed, no modules loaded.
2022-07-14 15:12:29.784457719
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c

<no location info>: error: can't find file: .hs
Failed, no modules loaded.
2022-07-14 15:13:00.507927303
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:13:00.603629594
>>> let2int 'a'
97
2022-07-14 15:13:39.732304028
>>> let2int 'z'
122
2022-07-14 15:13:51.492684476
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:15:17.444173584
>>> let2int 'a'
0
2022-07-14 15:15:36.20744161
>>> let2int 'z'
25
2022-07-14 15:15:53.251491821
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr i(i + ord 'a')
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:9:13: error:
    • Couldn't match expected type ‘Int -> Char’
                  with actual type ‘Char’
    • The function ‘chr’ is applied to two value arguments,
        but its type ‘Int -> Char’ has only one
      In the expression: chr i (i + ord 'a')
      In an equation for ‘int2let’: int2let i = chr i (i + ord 'a')
  |
9 | int2let i = chr i(i + ord 'a')
  |             ^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 15:20:17.343902559
>>> int2let 25

<interactive>:11:1: error:
    Variable not in scope: int2let :: t0 -> t
2022-07-14 15:20:31.206056217
>>> int2let 25

<interactive>:12:1: error:
    Variable not in scope: int2let :: t0 -> t
2022-07-14 15:20:49.379424997
>>> int2let 25

<interactive>:13:1: error:
    Variable not in scope: int2let :: t0 -> t
2022-07-14 15:21:49.224305814
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:21:53.138720708
>>> int2let 25
'z'
2022-07-14 15:22:04.571923117
>>> shift (-3) 'd'

<interactive>:16:1: error:
    Variable not in scope: shift :: t0 -> Char -> t
2022-07-14 15:28:25.82648516
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) 'mod' 26)
  14      | otherwise = c
  15      
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:44: error:
    • Syntax error on 'mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'mod'
   |
13 |     | isLower c = int2let ((let2int c + n) 'mod' 26)
   |                                            ^^^^^
Failed, no modules loaded.
2022-07-14 15:28:30.56505598
>>> shift (-3) 'd'

<interactive>:18:1: error:
    Variable not in scope: shift :: t0 -> Char -> t
2022-07-14 15:29:02.758751902
>>> shift 3 'z'

<interactive>:19:1: error:
    Variable not in scope: shift :: t0 -> Char -> t
2022-07-14 15:29:38.397543769
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) 'mod' 26)
  14      | otherwise = c
  15      
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:44: error:
    • Syntax error on 'mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'mod'
   |
13 |     | isLower c = int2let ((let2int c + n) 'mod' 26)
   |                                            ^^^^^
Failed, no modules loaded.
2022-07-14 15:31:55.767782497
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) 'mod' 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:44: error:
    • Syntax error on 'mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'mod'
   |
13 |     | isLower c = int2let ((let2int c + n) 'mod' 26)
   |                                            ^^^^^
Failed, no modules loaded.
2022-07-14 15:32:33.195454636
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) 'mod' 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:44: error:
    • Syntax error on 'mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'mod'
   |
13 |     | isLower c = int2let ((let2int c + n) 'mod' 26)
   |                                            ^^^^^
Failed, no modules loaded.
2022-07-14 15:33:25.303393317
>>> encode 3 "haskell is fun"

<interactive>:23:1: error:
    Variable not in scope: encode :: t0 -> t1 -> t
2022-07-14 15:37:11.518060955
>>> it

<interactive>:24:1: error:
    • Variable not in scope: it
    • Perhaps you meant ‘id’ (imported from Prelude)
2022-07-14 15:48:28.0818312
>>> encode (-3) it

<interactive>:25:1: error:
    Variable not in scope: encode :: t0 -> t1 -> t

<interactive>:25:13: error:
    • Variable not in scope: it
    • Perhaps you meant ‘id’ (imported from Prelude)
2022-07-14 15:49:25.186106725
>>> let2int 'a'

<interactive>:26:1: error:
    Variable not in scope: let2int :: Char -> t
2022-07-14 15:52:02.857193234
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) 'mod' 26)
  14      | otherwise = c
  15  
  16  encode :: Int ->    (String -> String)    
  17  encode n xs = [ shift n x | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:44: error:
    • Syntax error on 'mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'mod'
   |
13 |     | isLower c = int2let ((let2int c + n) 'mod' 26)
   |                                            ^^^^^
Failed, no modules loaded.
2022-07-14 15:53:26.965232113
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) 'mod' 26)
  14      | otherwise = c
  15  
  16  encode :: Int ->    (String -> String)    
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24          
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:44: error:
    • Syntax error on 'mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'mod'
   |
13 |     | isLower c = int2let ((let2int c + n) 'mod' 26)
   |                                            ^^^^^
Failed, no modules loaded.
2022-07-14 15:59:19.625949584
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) 'mod' 26)
  14      | otherwise = c
  15  
  16  encode :: Int ->    (String -> String)    
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24          
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:44: error:
    • Syntax error on 'mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'mod'
   |
13 |     | isLower c = int2let ((let2int c + n) 'mod' 26)
   |                                            ^^^^^
Failed, no modules loaded.
2022-07-14 16:00:02.072178338
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) 'mod' 26)
  14      | otherwise = c
  15  
  16  encode :: Int ->    (String -> String)    
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24          
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:44: error:
    • Syntax error on 'mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'mod'
   |
13 |     | isLower c = int2let ((let2int c + n) 'mod' 26)
   |                                            ^^^^^
Failed, no modules loaded.
2022-07-14 16:00:04.904377074
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n)'mod' 26)
  14      | otherwise = c
  15  
  16  encode :: Int ->    (String -> String)    
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24          
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:43: error:
    • Syntax error on 'mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'mod'
   |
13 |     | isLower c = int2let ((let2int c + n)'mod' 26)
   |                                           ^^^^^
Failed, no modules loaded.
2022-07-14 16:00:28.597504811
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) 'Mod' 26)
  14      | otherwise = c
  15  
  16  encode :: Int ->    (String -> String)    
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24          
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:44: error:
    • Syntax error on 'Mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'Mod'
   |
13 |     | isLower c = int2let ((let2int c + n) 'Mod' 26)
   |                                            ^^^^^
Failed, no modules loaded.
2022-07-14 16:00:52.618522596
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) 'Mod' 26)
  14      | otherwise = c
  15  
  16  encode :: Int ->    (String -> String)    
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24          
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:44: error:
    • Syntax error on 'Mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'Mod'
   |
13 |     | isLower c = int2let ((let2int c + n) 'Mod' 26)
   |                                            ^^^^^
Failed, no modules loaded.
2022-07-14 16:00:57.329365371
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int ->    (String -> String)    
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24          
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:04:36.005001429
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int ->    (String -> String)    
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24          
Ok, one module loaded.
2022-07-14 16:04:41.931249214
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int ->    (String -> String)    
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n  / fromIntegral m) * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:08:55.024908248
>>> percent 5 15
33.333336
2022-07-14 16:09:18.791242522
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int ->    (String -> String)    
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n  / fromIntegral m) * 100
  26  
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:15:28.098015078
>>> :q
Leaving GHCi.
